import os
from dotenv import load_dotenv

# FastAPI imports
from fastapi import FastAPI
from pydantic import BaseModel
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware

# LangChain imports
from langchain_community.utilities import SQLDatabase
from langchain_core.prompts import PromptTemplate 
from langchain_openai import ChatOpenAI
from langchain_core.callbacks import BaseCallbackHandler
from langchain_community.agent_toolkits.sql.base import create_sql_agent

# Load environment variables from .env file
load_dotenv()

# Set the OpenAI API key from the environment variables
os.environ["OPENAI_API_KEY"] = os.getenv("OPENAI_API_KEY")
DATABASE_URL = os.getenv("DATABASE_URL")

# Initialize the FastAPI application
app = FastAPI(
    title="Text-to-SQL Agent API",
    description="An API endpoint to convert natural language questions into SQL queries and fetch results."
)

origins = [
    "http://127.0.0.1:8000",
    "http://localhost:8000",
    "http://127.0.0.1:8080", 
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Define the expected structure for the incoming request
class Question(BaseModel):
    question: str


# Initialize the SQLDatabase utility (LangChain's interface for SQLAlchemy)
db = SQLDatabase.from_uri(DATABASE_URL)

# Initialize the OpenAI LLM
llm = ChatOpenAI(
    model="gpt-4o-mini", 
    temperature=0
)

class SQLQueryCallbackHandler(BaseCallbackHandler):
    """Callback handler to track the SQL query generated by the agent."""
    def __init__(self):
        self.sql_query = None

    def on_tool_start(self, serialized: dict, input_str: str, **kwargs) -> None:
        """Saves the SQL query string when the 'sql_db_query' tool is called."""
        # The agent writes the SQL and passes it as the input_str to the tool.
        if serialized.get("name") == "sql_db_query":
            self.sql_query = input_str
        
    def on_tool_end(self, output: str, **kwargs) -> None:
        """Resets the query after the tool execution is complete."""
        pass # We keep the query saved until the main function retrieves it

CUSTOM_FINAL_INSTRUCTION = """
You are a Text-to-SQL Assistant. Your primary goal is to accurately answer the user's question using SQL.

IMPORTANT RULES:
1. You MUST run a SQL query to answer every question â€” never guess.
2. If the SQL query returns zero rows, you MUST clearly answer:
   "No results found."
3. Never infer, assume, or fabricate data that does not appear in the SQL result.
4. Only base your final answer on the SQL tool output.
5. If the answer contains multiple items, present them as a numbered list (1., 2., 3...). 
6. If the answer is a single fact, respond in one short, clear sentence.

{input} 
{agent_scratchpad}
"""

# Create the PromptTemplate object
custom_prompt = PromptTemplate(
    input_variables=["input", "agent_scratchpad", "table_info", "top_k"],
    template=CUSTOM_FINAL_INSTRUCTION
)

# Create the LangChain SQL Agent (Updated Call)
agent_executor = create_sql_agent(
    llm=llm,
    db=db,
    agent_type="openai-functions",
    verbose=True,
    prompt=custom_prompt,
    max_iterations=10,
    return_intermediate_steps=True
)
# The agent is now ready to be called!

# FASTAPI ENDPOINT

# main.py (The FastAPI endpoint)

@app.post("/ask")
async def ask_database(question: Question):
    """
    Receives a natural language question, passes it to the Text-to-SQL Agent, 
    and returns the final answer along with the generated SQL query.
    """
    # 1. Initialize the custom handler
    sql_handler = SQLQueryCallbackHandler()
    
    try:
        # 2. Run the agent, passing the handler in the 'callbacks' list
        result = agent_executor.invoke(
            {"input": question.question},
            config={"callbacks": [sql_handler]}
        )
        
        final_answer = result.get("output", "Could not retrieve a definitive answer.")
        
        # 3. Retrieve the captured SQL query from the handler
        generated_sql = sql_handler.sql_query if sql_handler.sql_query else "SQL generation failed or was not necessary."

        return {
            "status": "success",
            "question": question.question,
            "answer": final_answer,
            "sql_query": generated_sql # <-- Sending the SQL back to the frontend
        }
    except Exception as e:
        print(f"Agent execution failed: {e}")
        return {
            "status": "error",
            "message": f"An error occurred during agent execution. Check server logs. Error: {e}",
            "sql_query": "Error: Agent failed before executing SQL."
        }

app.mount("/", StaticFiles(directory="frontend", html=True), name="frontend_app")

if __name__ == "__main__":
    import uvicorn
    # Command to run the server locally on port 8000
    uvicorn.run(app, host="0.0.0.0", port=8000)